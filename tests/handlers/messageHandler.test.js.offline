const { messageHandler } = require('../../src/handlers/messageHandler');
const OpenAiManager = require('../../src/managers/OpenAiManager');

// Mocking DiscordManager to avoid actual Discord interactions
jest.mock('../../src/managers/DiscordManager', () => ({
  getInstance: jest.fn().mockReturnValue({
    client: {
      login: jest.fn().mockResolvedValue(true),
      // Additional client methods if necessary
    },
  }),
}));

// Mocking configurationManager to provide test configurations
jest.mock('../../src/config/configurationManager', () => ({
  getConfig: jest.fn().mockImplementation((key) => {
    switch (key) {
      case 'DISCORD_TOKEN':
        return 'test-token';
      // Add more configuration keys as needed
      default:
        return null;
    }
  }),
}));

// Mocking discord.js Client, Channels, and Users
jest.mock('discord.js', () => ({
  Client: jest.fn().mockReturnValue({
    login: jest.fn().mockResolvedValue(true),
    channels: {
      fetch: jest.fn().mockResolvedValue({
        messages: {
          fetch: jest.fn().mockResolvedValue({
            array: () => [{ id: '123', content: 'Mock message', reply: jest.fn() }],
          }),
        },
        send: jest.fn().mockResolvedValue({ id: '456', content: 'Mock sent message' }),
      }),
    },
    users: {
      fetch: jest.fn().mockResolvedValue({ id: 'user123', username: 'MockUser' }),
    },
  }),
  GatewayIntentBits: {},
  TextChannel: jest.fn(),
  DMChannel: jest.fn(),
  NewsChannel: jest.fn(),
}));

// Mocking OpenAiManager
jest.mock('../../src/managers/OpenAiManager', () => ({
  getInstance: jest.fn().mockReturnValue({
    sendRequest: jest.fn(),
    getIsResponding: jest.fn().mockReturnValue(false),
    setIsResponding: jest.fn(),
  }),
}));

// Define a utility function to create mock messages
const createMockMessage = ({ content = '', channelId = 'defaultChannelId', authorId = 'defaultAuthorId' } = {}) => ({
  content,
  reply: jest.fn(),
  channelId,
  author: { id: authorId, username: 'MockUser' },
});

describe('messageHandler robustness', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
  });

  it('processes message correctly with successful OpenAiManager response', async () => {
    const testResponse = "This is a test response from OpenAI.";
    OpenAiManager.getInstance().sendRequest.mockResolvedValue([testResponse]);

    const mockMessage = createMockMessage({ content: 'Test message' });

    await messageHandler(mockMessage);

    expect(OpenAiManager.getInstance().sendRequest).toHaveBeenCalledTimes(1);
    expect(mockMessage.reply).toHaveBeenCalledWith(testResponse);
  });

  it('handles failure from OpenAiManager gracefully', async () => {
    OpenAiManager.getInstance().sendRequest.mockRejectedValue(new Error("Failed to fetch"));

    const mockMessage = createMockMessage({ content: 'Test failure scenario' });

    await messageHandler(mockMessage);

    expect(OpenAiManager.getInstance().sendRequest).toHaveBeenCalledTimes(1);
    expect(mockMessage.reply).toHaveBeenCalledWith(expect.stringContaining("Error"));
  });
});
